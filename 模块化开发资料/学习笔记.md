#### 1,模块化的演变
1，基于文件的划分模块的方式
具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）
缺点十分明显：
所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，
而且模块一但多了过后，容易产生命名冲突，
另外无法管理模块与模块之间的依赖关系；
2，每个模块只暴露一个全局对象，所有模块成员都挂载到这个对象中
具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。
缺点：
通过「命名空间」减小了命名冲突的可能，
但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，
而且也无法管理模块之间的依赖关系。
3，使用立即执行函数表达式（IIFE）为模块提供私有空间
具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现
有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。
4，利用 IIFE 参数作为依赖声明使用
具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。这使得每一个模块之间的关系变得更加明显。
5，模块化规范的出现
Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器

#### 2，ES6模块化的特点
1，通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了
2，ESM 自动采用严格模式，忽略 'use strict'
3，每个 ES Module 都是运行在单独的私有作用域中
4，ESM 是通过 CORS 的方式请求外部 JS 模块的
5，ESM 的 script 标签会延迟执行脚本