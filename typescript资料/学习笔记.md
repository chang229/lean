#### 1,强类型和弱类型(类型安全)
强类型：在语言层面现在函数的实参类型必须与形参类型相同;
弱类型：在语言层面不会限制实参的类型;
强类型有更强的类型约束，而弱类型几乎没有任何约束；
强类型语言中不允许任意的隐式类型转换，而弱类型语言中允许任意的隐式类型转换；
变量类型允许随时改变的特点，不是强弱类型的差异；

#### 2,静态类型和动态类型(类型检查)
静态类型：一个变量在声明时它的类型就是明确的，声明过后，它的类型不允许再改变；
动态类型：在允许阶段才能明确变量的类型，而且变量的类型可以随时改变;

#### 3，Flow
Flow:是一个js的静态类型检查器
安装：yarn add flow-bin --save-dev
运行：yarn flow
在文件开头需要添加注解：`// @flow`

#### 4,TypeScript
javascript的超集
安装：yarn add typescript --save-dev
编译：yarn tsc index.ts

配置文件：运行yarn tsc --init 会自动生成tsconfig.json配置文件，文件中包含所有的配置信息
配置好配置文件再运行yarn tsc就会对整个项目进行编译

标准库就是内置对象所对应的声明；

中文错误提示：1，yarn tsc --locale zh-CN;
2, 打开vscode的配置选项，搜索typescript locale  设置为zh-CN

#### object类型
object类型并不单指对象，而是除了原始类型以外的其他类型；
对象的限制可以使用类似对象字面量的方式，但更专业的方式是使用接口；
```
// object 类型是指除了原始类型以外的其它类型
const foo: object = function () {} // [] // {}

// 如果需要明确限制对象类型，则应该使用这种类型对象字面量的语法，或者是「接口」
const obj: { foo: number, bar: string } = { foo: 123, bar: 'string' }
```

#### 数组类型
数组类型有两种表示方法：
```
const arr1: Array<number> = [1,2,3];
const arr2: number[] = [1,2,3];
```
案例:
```
// 如果是 JS，需要判断是不是每个成员都是数字
// 使用 TS，类型有保障，不用添加类型判断
function sum (...args: number[]) {
  return args.reduce((prev, current) => prev + current, 0)
}

sum(1, 2, 3) // => 6
```

#### 元组类型
元组就是一个明确元素数量以及每个元素类型的数组；
```
comst temo:[number,string] = [123,'string'];
```

#### 枚举类型
标准的数字枚举
enum PostStatus {
   Draft = 0,
   Unpublished = 1,
   Published = 2
}

数字枚举，枚举值自动基于前一个值自增
enum PostStatus {
   Draft = 6,
   Unpublished, // => 7
   Published // => 8
}

// 常量枚举，不会侵入编译结果
const enum PostStatus {
  Draft,
  Unpublished,
  Published
}

#### 函数类型
如果某一个参数是非必填的，则在参数后面加一个问号表示：`b?:number`
```
function func1 (a: number, b: number = 10, ...rest: number[]): string {
  return 'func1'
}

func1(100, 200)

func1(100)

func1(100, 200, 300)

// -----------------------------------------

const func2: (a: number, b: number) => string = function (a: number, b: number): string {
  return 'func2'
}
```

#### 任意类型：any

#### 隐式类型推断
在没有给变量设置类型时，typescript会进行隐式类型推动，建议给每个变量设置类型；

#### 类型断言
在一些情况下typescript不能准确的判断变量的类型：
```
// 假定这个 nums 来自一个明确的接口
const nums = [110, 120, 119, 112]

const res = nums.find(i => i > 0) //在这里typescript推动res是number或者undefined;

const square = res * res //在这里使用乘法时就会报错;

//类型断言，告诉typescript res一定是number类型
const num1 = res as number

const num2 = <number>res // JSX 下不能使用
```